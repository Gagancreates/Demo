<dependencies>
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
        <version>5.0.1</version>
    </dependency>
    <dependency>
        <groupId>com.oracle.database.jdbc</groupId>
        <artifactId>ojdbc8</artifactId>
        <version>19.3.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ReliableOracleDatabaseSync {

    private static final Logger logger = LoggerFactory.getLogger(ReliableOracleDatabaseSync.class);

    private static final String SOURCE_DB_URL = "jdbc:oracle:thin:@//source_db_host:1521/source_service";
    private static final String SOURCE_DB_USER = "source_user";
    private static final String SOURCE_DB_PASSWORD = "source_password";

    private static final String TARGET_DB_URL = "jdbc:oracle:thin:@//target_db_host:1521/target_service";
    private static final String TARGET_DB_USER = "target_user";
    private static final String TARGET_DB_PASSWORD = "target_password";

    private static final int BATCH_SIZE = 1000;
    private static final int THREAD_POOL_SIZE = 10;
    private static final int MAX_RETRIES = 5;
    private static final long RETRY_DELAY_MS = 1000;

    public static void main(String[] args) throws InterruptedException {
        HikariDataSource sourceDataSource = createDataSource(SOURCE_DB_URL, SOURCE_DB_USER, SOURCE_DB_PASSWORD);
        HikariDataSource targetDataSource = createDataSource(TARGET_DB_URL, TARGET_DB_USER, TARGET_DB_PASSWORD);

        try (Connection sourceConnection = sourceDataSource.getConnection();
             Connection targetConnection = targetDataSource.getConnection()) {

            ExecutorService executor = Executors.newFixedThreadPool(THREAD_POOL_SIZE);
            for (int i = 0; i < THREAD_POOL_SIZE; i++) {
                final int chunkId = i;
                executor.submit(() -> {
                    try {
                        processChunk(sourceConnection, targetConnection, chunkId);
                    } catch (SQLException e) {
                        logger.error("Error processing chunk " + chunkId, e);
                    }
                });
            }
            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);

        } catch (SQLException e) {
            logger.error("Database connection error", e);
        } finally {
            sourceDataSource.close();
            targetDataSource.close();
        }
    }

    private static HikariDataSource createDataSource(String dbUrl, String dbUser, String dbPassword) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(dbUrl);
        config.setUsername(dbUser);
        config.setPassword(dbPassword);
        config.setMaximumPoolSize(THREAD_POOL_SIZE);
        config.setMinimumIdle(THREAD_POOL_SIZE);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);

        return new HikariDataSource(config);
    }

    private static void processChunk(Connection sourceConnection, Connection targetConnection, int chunkId) throws SQLException {
        String fetchSourceSQL = "SELECT id, data_column FROM source_table WHERE MOD(id, ?) = ? AND last_modified > ?";
        String upsertTargetSQL = "MERGE INTO target_table t USING (SELECT ? AS id, ? AS data_column FROM dual) s " +
                                 "ON (t.id = s.id) " +
                                 "WHEN MATCHED THEN UPDATE SET t.data_column = s.data_column " +
                                 "WHEN NOT MATCHED THEN INSERT (id, data_column) VALUES (s.id, s.data_column)";

        long lastSyncTimestamp = getLastSyncTimestamp(targetConnection);

        try (PreparedStatement sourceStatement = sourceConnection.prepareStatement(fetchSourceSQL);
             PreparedStatement targetStatement = targetConnection.prepareStatement(upsertTargetSQL)) {

            sourceStatement.setInt(1, THREAD_POOL_SIZE);
            sourceStatement.setInt(2, chunkId);
            sourceStatement.setTimestamp(3, new java.sql.Timestamp(lastSyncTimestamp));
            sourceStatement.setFetchSize(BATCH_SIZE);

            ResultSet resultSet = sourceStatement.executeQuery();
            targetConnection.setAutoCommit(false);

            int count = 0;
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String dataColumn = resultSet.getString("data_column");

                targetStatement.setInt(1, id);
                targetStatement.setString(2, dataColumn);
                targetStatement.addBatch();

                count++;
                if (count % BATCH_SIZE == 0) {
                    executeBatchWithRetries(targetStatement, targetConnection);
                }
            }
            executeBatchWithRetries(targetStatement, targetConnection);
            resultSet.close();

            updateLastSyncTimestamp(targetConnection, System.currentTimeMillis());
        }
    }

    private static void executeBatchWithRetries(PreparedStatement targetStatement, Connection targetConnection) throws SQLException {
        int retryCount = 0;
        boolean success = false;
        while (retryCount < MAX_RETRIES && !success) {
            try {
                targetStatement.executeBatch();
                targetConnection.commit();
                success = true;
                logger.info("Batch executed successfully");
            } catch (SQLException e) {
                targetConnection.rollback();
                retryCount++;
                logger.warn("Retrying batch execution: attempt " + retryCount, e);
                if (retryCount >= MAX_RETRIES) {
                    throw e;
                }
                try {
                    Thread.sleep(RETRY_DELAY_MS);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private static long getLastSyncTimestamp(Connection connection) throws SQLException {
        String query = "SELECT last_sync_timestamp FROM sync_metadata WHERE table_name = 'target_table'";
        try (PreparedStatement statement = connection.prepareStatement(query);
             ResultSet resultSet = statement.executeQuery()) {

            long lastSyncTimestamp = 0;
            if (resultSet.next()) {
                lastSyncTimestamp = resultSet.getLong("last_sync_timestamp");
            }
            logger.info("Last sync timestamp: " + lastSyncTimestamp);
            return lastSyncTimestamp;
        }
    }

    private static void updateLastSyncTimestamp(Connection connection, long newTimestamp) throws SQLException {
        String updateSQL = "UPDATE sync_metadata SET last_sync_timestamp = ? WHERE table_name = 'target_table'";
        try (PreparedStatement statement = connection.prepareStatement(updateSQL)) {
            statement.setLong(1, newTimestamp);
            statement.executeUpdate();
            logger.info("Updated last sync timestamp to: " + newTimestamp);
        }
    }
}


        <version>1.7.36</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>1.7.36</version>
    </dependency>
</dependencies>

