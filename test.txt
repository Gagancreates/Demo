CREATE TABLE sync_status_table (
    id            NUMBER PRIMARY KEY,
    last_modified TIMESTAMP,
    sync_status   VARCHAR2(20),
    retry_count   NUMBER DEFAULT 0,
    last_synced   TIMESTAMP
);
private static void processChunk(Connection sourceConnection, Connection targetConnection, int chunkId) throws SQLException {
    String fetchSourceSQL = "SELECT id, data_column, sync_status FROM source_table WHERE MOD(id, ?) = ? AND last_modified > ? AND sync_status = 'PENDING'";
    String updateSyncStatusSQL = "UPDATE source_table SET sync_status = ? WHERE id = ?";
    String upsertTargetSQL = "MERGE INTO target_table t USING (SELECT ? AS id, ? AS data_column FROM dual) s " +
                             "ON (t.id = s.id) " +
                             "WHEN MATCHED THEN UPDATE SET t.data_column = s.data_column " +
                             "WHEN NOT MATCHED THEN INSERT (id, data_column) VALUES (s.id, s.data_column)";

    long lastSyncTimestamp = getLastSyncTimestamp(targetConnection);

    try (PreparedStatement sourceStatement = sourceConnection.prepareStatement(fetchSourceSQL);
         PreparedStatement targetStatement = targetConnection.prepareStatement(upsertTargetSQL);
         PreparedStatement updateSyncStatusStatement = sourceConnection.prepareStatement(updateSyncStatusSQL)) {

        sourceStatement.setInt(1, THREAD_POOL_SIZE);
        sourceStatement.setInt(2, chunkId);
        sourceStatement.setTimestamp(3, new java.sql.Timestamp(lastSyncTimestamp));
        sourceStatement.setFetchSize(BATCH_SIZE);

        ResultSet resultSet = sourceStatement.executeQuery();
        targetConnection.setAutoCommit(false);

        int count = 0;
        while (resultSet.next()) {
            int id = resultSet.getInt("id");
            String dataColumn = resultSet.getString("data_column");

            // Set sync status to 'IN_PROGRESS'
            updateSyncStatusStatement.setString(1, "IN_PROGRESS");
            updateSyncStatusStatement.setInt(2, id);
            updateSyncStatusStatement.executeUpdate();

            targetStatement.setInt(1, id);
            targetStatement.setString(2, dataColumn);
            targetStatement.addBatch();

            count++;
            if (count % BATCH_SIZE == 0) {
                executeBatchWithRetries(targetStatement, targetConnection, updateSyncStatusStatement);
            }
        }
        executeBatchWithRetries(targetStatement, targetConnection, updateSyncStatusStatement);
        resultSet.close();

        updateLastSyncTimestamp(targetConnection, System.currentTimeMillis());
    }
}

private static void executeBatchWithRetries(PreparedStatement targetStatement, Connection targetConnection, PreparedStatement updateSyncStatusStatement) throws SQLException {
    int retryCount = 0;
    boolean success = false;
    while (retryCount < MAX_RETRIES && !success) {
        try {
            targetStatement.executeBatch();
            targetConnection.commit();
            
            // If batch is successful, mark records as 'SYNCED'
            updateSyncStatusStatement.setString(1, "SYNCED");
            updateSyncStatusStatement.executeBatch();
            
            success = true;
            logger.info("Batch executed successfully");
        } catch (SQLException e) {
            targetConnection.rollback();
            retryCount++;
            logger.warn("Retrying batch execution: attempt " + retryCount, e);
            if (retryCount >= MAX_RETRIES) {
                throw e;
            }
            try {
                Thread.sleep(RETRY_DELAY_MS);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

